{
  "translatorID": "ca65189f-8815-4afe-8c8b-8c7c15f0edca",
  "label": "Better BibTeX",
  "creator": "Simon Kornblith, Richard Karnesky and Emiliano heyns",
  "target": "bib",
  "minVersion": "2.1.9",
  "maxVersion": "",
  "priority": 199,
  "configOptions": {
    "getCollections": "true"
  },
  "displayOptions": {
    "exportNotes": true,
    "exportFileData": false,
    "useJournalAbbreviation": false,
    "Export Collections": true
  },
  "inRepository": true,
  "translatorType": 3,
  "browserSupport": "gcsv"
}

// @include "translator.js"

Translator.fieldMap = Dict({
  // Zotero     BibTeX
  place:        {name: 'address', protect: true, import: 'location'},
  section:      {name: 'chapter', protect: true},
  edition:      {name: 'edition', protect: true},
  type:         {name: 'type'},
  series:       {name: 'series', protect: true},
  title:        {name: 'title', protect: true},
  volume:       {name: 'volume', protect: true},
  rights:       {name: 'copyright', protect: true},
  ISBN:         {name: 'isbn'},
  ISSN:         {name: 'issn'},
  callNumber:   {name: 'lccn'},
  shortTitle:   {name: 'shorttitle', protect: true},
  url:          {name: 'url', esc: 'url'},
  DOI:          {name: 'doi', esc: 'doi'},
  abstractNote: {name: 'abstract'},
  country:      {name: 'nationality'},
  language:     {name: 'language'},
  assignee:     {name: 'assignee'},
  issue:        {import: 'issue'},

  publicationTitle: {import: 'booktitle'},
  publisher:        {import: ['school', 'institution', 'publisher']},
});

Translator.typeMap = Dict({
  // BibTeX                            Zotero
  // ----------------------------------------
  'book booklet manual proceedings':  'book',
  'incollection inbook':              'bookSection',
  'article misc':                     'journalArticle magazineArticle newspaperArticle',
  'phdthesis mastersthesis':          'thesis',
  'unpublished':                      'manuscript',
  'patent':                           'patent',
  'inproceedings conference':         'conferencePaper',
  'techreport':                       'report',
  'misc':                             'letter interview film artwork webpage'
});

/*
 * three-letter month abbreviations. I assume these are the same ones that the
 * docs say are defined in some appendix of the LaTeX book. (i don't have the
 * LaTeX book.)
*/
var months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

function doExport() {
  //Zotero.write('% BibTeX export generated by Zotero '+Zotero.Utilities.getVersion());
  // to make sure the BOM gets ignored
  Zotero.write("\n");

  for_each (let item from Translator.nextItem()) {
    var ref = new Translator.Reference(item);

    ref.add({name: 'number', value: item.reportNumber || item.issue || item.seriesNumber || item.patentNumber});
    ref.add({name: 'urldate', value: item.accessDate && item.accessDate.replace(/\s*\d+:\d+:\d+/, '')});

    switch (item.itemType) {
      case 'bookSection':
      case 'conferencePaper':
        ref.add({name: 'booktitle', value: item.publicationTitle, protect: true});
        break;

      default:
        ref.add({name: 'journal', value: (Translator.useJournalAbbreviation && Zotero.BetterBibTeX.keymanager.journalAbbrev(item)) || item.publicationTitle, protect: true});
        break;
    }

    switch (item.itemType) {
      case 'thesis':
        ref.add({name: 'school', value: item.publisher, protect: true});
        break;

      case 'report':
        ref.add({name: 'institution', value: item.publisher, protect: true});
        break;

      default:
        ref.add({name: 'publisher', value: item.publisher, protect: true});
        break;
    }

    if (item.creators && item.creators.length) {
      // split creators into subcategories
      var authors = [];
      var editors = [];
      var translators = [];
      var collaborators = [];
      var primaryCreatorType = Zotero.Utilities.getCreatorsForType(item.itemType)[0];

      for_each (let creator in item.creators) {
        if (('' + creator.firstName).trim() !== '' && ('' + creator.lastName).trim() !== '') {
          creatorString = creator.lastName + ', ' + creator.firstName;
        } else {
          creatorString = String(creator.lastName);
        }

        switch (creator.creatorType) {
          case 'editor':
          case 'seriesEditor':
            editors.push(creatorString);
            break;

          case 'translator':
            translators.push(creatorString);
            break;

          case primaryCreatorType:
            authors.push(creatorString);
            break;

          default:
            collaborators.push(creatorString);
        }
      }

      ref.add({name: 'author', value: authors, sep: ' and '});
      ref.add({name: 'editor', value: editors, sep: ' and '});
      ref.add({name: 'translator', value: translators, sep: ' and '});
      ref.add({name: 'collaborator', value: collaborators, sep: ' and '});
    }

    if (item.date) {
      var date = Zotero.Utilities.strToDate(item.date);
      if (typeof date.year === 'undefined') {
        ref.add({name: 'year', value: item.date, protect: true});
      } else {
        // need to use non-localized abbreviation
        if (typeof date.month == 'number') {
          ref.add({name: 'month', value: months[date.month], braces: false});
        }
        ref.add({name: 'year', value: date.year});
      }
    }

    ref.add({name: 'note', value: item.extra});

    ref.add({name: 'keywords', value: item.tags, esc: 'tags'});

    ref.add({name: 'pages', value: item.pages && item.pages.replace(/[-\u2012-\u2015\u2053]+/g,"--")});

    // Commented out, because we don't want a books number of pages in the BibTeX "pages" field for books.
    //if (item.numPages) {
    //  writeField('pages', latex_escape(item.numPages));
    //}

    /* We'll prefer url over howpublished see
    https://forums.zotero.org/discussion/24554/bibtex-doubled-url/#Comment_157802

    if (item.itemType == 'webpage') {
      writeField('howpublished', item.url);
    }*/
    if (item.notes && Translator.exportNotes) {
      for_each (let note in item.notes) {
        ref.add({name: 'annote', value: Zotero.Utilities.unescapeHTML(note.note)});
      }
    }

    ref.add({name: 'file', value:item.attachments, esc: 'attachments'});

    ref.complete();
  }

  Translator.exportGroups();

  Zotero.write("\n");
}

function addToExtra(item, str) {
  if (item.extra && item.extra !== '') {
    item.extra += " \n" + str;
  } else {
    item.extra = str;
  }
}

function addToExtraData(data, key, value) {
  data.push(key.replace(/[=;]/g, '#') + '=' + value.replace(/[\r\n]+/g, ' ').replace(/[=;]g/, '#'));
}

var fieldMap = null;
function createZoteroReference(bibtexitem) {
  if (!fieldMap) {
    fieldMap = Dict();
    var fields;
    for_each (let attr: let field of Translator.fieldMap) {
      fields = [];
      if (field.name) { fields.push(field.name); }
      if (field.import) { fields = fields.concat(field.import); }
      for_each (let f in fields) {
        if (!fieldMap[f]) {
          fieldMap[f] = attr;
        }
      }
    }
  }

  var type = Zotero.Utilities.trimInternal(bibtexitem.__type__.toLowerCase());
  if (bibtexitem.type) { type = Zotero.Utilities.trimInternal(bibtexitem.type.toLowerCase()); }
  type = Translator.typeMap.BibTeX2Zotero[type] || 'journalArticle';

  var item = new Zotero.Item(type);
  item.itemID = bibtexitem.__key__;

  if (bibtexitem.__note__) {
    item.notes.push({note: ('The following fields were not imported:<br/>' + bibtexitem.__note__).trim(), tags: ['#BBT Import']});
  }

  function keywordClean(k) {
    return k.replace(/^[\s{]+|[}\s]+$/gm, '').trim();
  }

  var biblatexdata = [];
  for_each (let field:let value of bibtexitem) {
    if (['__note__', '__key__', '__type__', 'type', 'added-at', 'timestamp'].indexOf(field) >= 0) { continue; }
    if (!value) { continue; }
    if (typeof value == 'string') { value = Zotero.Utilities.trim(value); }
    if (value === '') { continue; }

    if (fieldMap[field]) {
      item[fieldMap[field]] = value;

    } else if (field == 'journal') {
      if (item.publicationTitle) {
        item.journalAbbreviation = value;
      } else {
        item.publicationTitle = value;
      }

    } else if (field == 'fjournal') {
      if (item.publicationTitle) {
        // move publicationTitle to abbreviation
        item.journalAbbreviation = item.publicationTitle;
      }
      item.publicationTitle = value;

    } else if (field == 'author' || field == 'editor' || field == 'translator') {
      for_each (let creator in value) {
        if (!creator) { continue; }

        if (typeof creator == 'string') {
          creator = Zotero.Utilities.cleanAuthor(creator, field, false);
        } else {
          creator.creatorType = field;
        }

        item.creators.push(creator);
      };

    } else if (field == 'institution' || field == 'organization') {
      item.backupPublisher = value;

    } else if (field == 'number'){ // fix for techreport
      if (item.itemType == 'report') {
        item.reportNumber = value;
      } else if (item.itemType == 'book' || item.itemType == 'bookSection') {
        item.seriesNumber = value;
      } else if (item.itemType == 'patent'){
        item.patentNumber = value;
      } else {
        item.issue = value;
      }

    } else if (field == 'month') {
      var monthIndex = months.indexOf(value.toLowerCase());
      if (monthIndex >= 0) {
        value = Zotero.Utilities.formatDate({month:monthIndex});
      } else {
        value += ' ';
      }

      if (item.date) {
        if (value.indexOf(item.date) >= 0) {
          // value contains year and more
          item.date = value;
        } else {
          item.date = value+item.date;
        }
      } else {
        item.date = value;
      }

    } else if (field == 'year') {
      if (item.date) {
        if (item.date.indexOf(value) < 0) {
          // date does not already contain year
          item.date += value;
        }
      } else {
        item.date = value;
      }

    } else if (field == 'date') {
      //We're going to assume that 'date' and the date parts don't occur together. If they do, we pick date, which should hold all.
      item.date = value;

    } else if (field == 'pages') {
      if (item.itemType == 'book' || item.itemType == 'thesis' || item.itemType == 'manuscript') {
        item.numPages = value;
      } else {
        item.pages = value.replace(/--/g, '-');
      }

    } else if (field == 'note') {
      addToExtra(item, value);

    } else if (field == 'howpublished') {
      if (/^(https?:\/\/|mailto:)/i.test(value)) {
        item.url = value;
      } else {
        addToExtraData(biblatexdata, field, value);
      }

    //accept lastchecked or urldate for access date. These should never both occur.
    //If they do we don't know which is better so we might as well just take the second one
    } else if (field == 'lastchecked'|| field == 'urldate'){
      item.accessDate = value;

    } else if (field == 'keywords' || field == 'keyword') {
      var kw = value.split(/[,;]/);
      if (kw.length == 1) {
        kw = value.split(/\s+/);
      }
      item.tags = kw.map(keywordClean);

    } else if (field == 'comment' || field == 'annote' || field == 'review' || field == 'notes') {
      item.notes.push({note:Zotero.Utilities.text2html(value)});

    } else if (field == 'file') {
      for_each (let att in value) {
        item.attachments.push(att);
      }

    } else {
      addToExtraData(biblatexdata, field, value);

    }
  }

  if (item.itemType == 'conferencePaper' && item.publicationTitle && !item.proceedingsTitle) {
    item.proceedingsTitle = item.publicationTitle;
    delete item.publicationTitle;
  }

  addToExtra(item, 'bibtex: ' + item.itemID);

  if (biblatexdata.length > 0) {
    biblatexdata.sort();
    addToExtra(item, "biblatexdata[" + biblatexdata.join(';') + ']');
  }

  if (!item.publisher && item.backupPublisher){
    item.publisher=item.backupPublisher;
    delete item.backupPublisher;
  }

  item.complete();
  return item;
}

// @include "import.js"
